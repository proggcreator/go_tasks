1.Какой самый эффективный способ работы с объединением строк?

- Обычный способ s := fmt.Sprintf("Size: %d MB.", 85)
- Эффективный (высокопроизводительный) strings.Builder (позволяет безопасно избежать дополнительного копирования при преобразовании Builder в строку)
var b strings.Builder
	b.Grow(32) 		// предварительное выделения памяти
	for i, p := range []int{2, 3, 5, 7, 11, 13} {
		fmt.Fprintf(&b, "%d:%d, ", i+1, p)
	}
	s := b.String()   // нет копирования
	s = s[:b.Len()-2] // нет копирования, удаляет завершающий ", "	   
	fmt.Println(s)

	
2.Что такое интерфейсы, как они применяются в Go?
Интерфейс это абстракция поведения других типов(нельзя напрямую содать обьект интерфейса). 
Интерфейсы определяют некоторый функционал, но не реализуют его.
В Go интерфейс реализуется неявно.Не надо специально указывать, что структуры применяют определенный интерфейс
Для реализации типу данных достаточно реализовать методы, которые определяет интерфейс.
Интерфейсы позволяют определить какую-то обобщенную реализацию без привязки к конкретному типу. 
type mystract1 struct {}
type inter interface {
	met()
}
func (s mystract1)  met ()  {
	fmt.Println("Method 1")
}
func  myfunc (u inter)  {
	u.met()
}
func main ()  {
	x := mystract1{}
	myfunc(x)	 	//одна функция принимает разные структуры
3.Чем отличаются RWMutex от Mutex?
Для блокирования доступа к общему разделяемому ресурсу 
Mutex - одна горулина захватывает мьютекс  Lock до Unlock (остальные ждут)
RWMutex - возможность параллельного считывания без блокировки (ждут только записи) блокировка по доступу
Замок может удерживаться произвольным числом считывателей или одним записывающим устройством.
4.Чем отличаются буферизированные и не буферизированные каналы?
Небуфер. Горутина-отправитель может отправлять данные только в пустой канал. Блокировка отправителя пока канал не освободится

5. Какой размер пустой структуры struct{}{}?
c := struct{}{}
fmt.Println(unsafe.Sizeof(c))
0 
6.Какой способ определения двух слайсов предпочтительнее?

7.Есть ли в Go перегрузка методов или операторов?
Нет, методы можно через интерфейс

8. какой последовательности будут выведены элементы map[int]int?
при использовании range порядка нет, можно сделать упорядоченный массив ключей

9.В чем разница make и new?
new  возвращает только указатели на инициализированную память
make предназначен для инициализации каналов, срезов и карт

10.Сколько существует способов создать переменную типа slice или map?
var x []int					var x map[string]int
x := make([]int, 5)			x := make(map[string]int)
x := []int{1,2,3}			x := map[string]string{"H": "Hydrogen","He": "Helium",}

make([]int, 50, 100)
new([100]int)[0:50]
